package sqlite

import (
	"context"
	"fmt"
	"time"

	"github.com/mr-karan/logchef/internal/sqlite/sqlc"
	"github.com/mr-karan/logchef/pkg/models"
)

// Session methods

// CreateSession inserts a new session record.
// Note: The CreatedAt timestamp is generated by the SQL query.
func (db *DB) CreateSession(ctx context.Context, session *models.Session) error {
	db.log.Debug("creating session record", "session_id", session.ID, "user_id", session.UserID)

	params := sqlc.CreateSessionParams{
		ID:        string(session.ID),
		UserID:    int64(session.UserID),
		ExpiresAt: session.ExpiresAt,
		CreatedAt: time.Now(), // Pass current time, though DB default takes precedence.
	}

	err := db.queries.CreateSession(ctx, params)
	if err != nil {
		db.log.Error("failed to create session record in db",
			"error", err,
			"session_id", session.ID,
			"user_id", session.UserID,
		)
		return fmt.Errorf("error creating session: %w", err)
	}
	// Timestamps like CreatedAt are set by the DB; caller doesn't need them updated on the input model typically.
	db.log.Debug("session record created successfully", "session_id", session.ID)
	return nil
}

// GetSession retrieves a session by its unique ID.
// Returns core.ErrSessionNotFound (via handleNotFoundError) if not found.
func (db *DB) GetSession(ctx context.Context, sessionID models.SessionID) (*models.Session, error) {
	db.log.Debug("getting session record", "session_id", sessionID)

	sqlcSession, err := db.queries.GetSession(ctx, string(sessionID))
	if err != nil {
		// Use handleNotFoundError for consistent not-found error handling.
		return nil, handleNotFoundError(err, fmt.Sprintf("getting session id %s", sessionID))
	}

	// Map sqlc result to domain model.
	session := &models.Session{
		ID:        models.SessionID(sqlcSession.ID),
		UserID:    models.UserID(sqlcSession.UserID),
		ExpiresAt: sqlcSession.ExpiresAt,
		CreatedAt: sqlcSession.CreatedAt,
	}

	return session, nil
}

// DeleteSession removes a specific session record by ID.
// Returns nil if the session was deleted or did not exist.
func (db *DB) DeleteSession(ctx context.Context, sessionID models.SessionID) error {
	db.log.Debug("deleting session record", "session_id", sessionID)

	err := db.queries.DeleteSession(ctx, string(sessionID))
	if err != nil {
		// sqlc Delete typically doesn't return ErrNoRows. Log other errors.
		db.log.Error("failed to delete session record from db",
			"error", err,
			"session_id", sessionID,
		)
		return fmt.Errorf("error deleting session: %w", err)
	}
	db.log.Debug("session record deleted successfully (or did not exist)", "session_id", sessionID)
	return nil
}

// DeleteUserSessions removes all session records associated with a specific user ID.
func (db *DB) DeleteUserSessions(ctx context.Context, userID models.UserID) error {
	db.log.Debug("deleting all session records for user", "user_id", userID)

	err := db.queries.DeleteUserSessions(ctx, int64(userID))
	if err != nil {
		db.log.Error("failed to delete user sessions from db",
			"error", err,
			"user_id", userID,
		)
		return fmt.Errorf("error deleting user sessions: %w", err)
	}
	db.log.Debug("all session records deleted for user", "user_id", userID)
	return nil
}

// CountUserSessions returns the number of currently active (non-expired) sessions for a user.
func (db *DB) CountUserSessions(ctx context.Context, userID models.UserID) (int, error) {
	db.log.Debug("counting active user sessions", "user_id", userID)

	// Count sessions where the expiration time is in the future.
	count, err := db.queries.CountUserSessions(ctx, sqlc.CountUserSessionsParams{
		UserID:    int64(userID),
		ExpiresAt: time.Now(),
	})
	if err != nil {
		db.log.Error("failed to count user sessions in db",
			"error", err,
			"user_id", userID,
		)
		return 0, fmt.Errorf("error counting user sessions: %w", err)
	}

	db.log.Debug("active user sessions counted", "user_id", userID, "count", int(count))
	return int(count), nil
}
