package sqlite

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"github.com/mr-karan/logchef/internal/sqlite/sqlc"
	"github.com/mr-karan/logchef/pkg/models"
)

// Source methods

// CreateSource inserts a new source record into the database using sqlc generated queries.
// It maps the domain model to the sqlc parameters and handles potential unique constraint errors.
// The source ID and timestamps are populated back into the input source model upon success.
func (db *DB) CreateSource(ctx context.Context, source *models.Source) error {
	db.log.Debug("creating source record", "name", source.Name, "database", source.Connection.Database, "table", source.Connection.TableName)

	// Map domain model to sqlc parameters.
	params := sqlc.CreateSourceParams{
		Name:              source.Name,
		MetaIsAutoCreated: boolToInt(source.MetaIsAutoCreated),
		MetaTsField:       source.MetaTSField,
		MetaSeverityField: sql.NullString{String: source.MetaSeverityField, Valid: source.MetaSeverityField != ""},
		Host:              source.Connection.Host,
		Username:          source.Connection.Username,
		Password:          source.Connection.Password,
		Database:          source.Connection.Database,
		TableName:         source.Connection.TableName,
		Description:       sql.NullString{String: source.Description, Valid: source.Description != ""},
		TtlDays:           int64(source.TTLDays),
	}

	// Execute the generated query.
	id, err := db.queries.CreateSource(ctx, params)
	if err != nil {
		// Provide a more specific error message for unique constraint violations.
		if IsUniqueConstraintError(err) && (strings.Contains(err.Error(), "database") || strings.Contains(err.Error(), "table_name")) {
			return handleUniqueConstraintError(err, "sources", "database_table", fmt.Sprintf("%s.%s", source.Connection.Database, source.Connection.TableName))
		}
		db.log.Error("failed to create source record in db", "error", err)
		return fmt.Errorf("error creating source record: %w", err)
	}

	// Set the auto-generated ID on the input model.
	source.ID = models.SourceID(id)

	// Fetch the created record again to get accurate timestamps generated by the database.
	// This ensures the model passed back to the caller has the correct creation/update times.
	sourceRow, err := db.queries.GetSource(ctx, id)
	if err != nil {
		db.log.Error("failed to get newly created source record", "error", err, "assigned_id", id)
		// Return success, but the timestamps on the input model might be slightly off.
		return nil
	}

	// Update the input model with the database-generated timestamps.
	newSource := mapSourceRowToModel(&sourceRow) // Assume mapSourceRowToModel handles potential nil
	if newSource != nil {
		source.CreatedAt = newSource.CreatedAt
		source.UpdatedAt = newSource.UpdatedAt
	}

	db.log.Debug("source record created", "source_id", source.ID, "name", source.Name)
	return nil
}

// GetSource retrieves a single source by its ID.
// It returns models.ErrNotFound if the source does not exist.
func (db *DB) GetSource(ctx context.Context, id models.SourceID) (*models.Source, error) {
	db.log.Debug("getting source record", "source_id", id)

	sourceRow, err := db.queries.GetSource(ctx, int64(id))
	if err != nil {
		// Use handleNotFoundError for consistent not-found error mapping.
		return nil, handleNotFoundError(err, fmt.Sprintf("getting source id %d", id))
	}

	// Map sqlc result to domain model.
	source := mapSourceRowToModel(&sourceRow)
	if source == nil {
		// This case should ideally be covered by handleNotFoundError, but as a safeguard:
		return nil, fmt.Errorf("internal error: source row for id %d mapped to nil", id)
	}
	return source, nil
}

// GetSourceByName retrieves a single source by its database and table name combination.
// It returns models.ErrNotFound if no matching source exists.
func (db *DB) GetSourceByName(ctx context.Context, database, tableName string) (*models.Source, error) {
	db.log.Debug("getting source record by name", "database", database, "table", tableName)

	sourceRow, err := db.queries.GetSourceByName(ctx, sqlc.GetSourceByNameParams{
		Database:  database,
		TableName: tableName,
	})
	if err != nil {
		// Explicitly map ErrNoRows to models.ErrNotFound for clarity.
		if errors.Is(err, sql.ErrNoRows) {
			return nil, models.ErrNotFound // Use the model-defined error
		}
		db.log.Error("failed to get source by name from db", "error", err, "database", database, "table", tableName)
		return nil, fmt.Errorf("error getting source by name: %w", err)
	}

	// Map sqlc result to domain model.
	source := mapSourceRowToModel(&sourceRow)
	if source == nil {
		return nil, fmt.Errorf("internal error: source row for %s.%s mapped to nil", database, tableName)
	}
	return source, nil
}

// ListSources retrieves all source records from the database, ordered by creation date.
func (db *DB) ListSources(ctx context.Context) ([]*models.Source, error) {
	db.log.Debug("listing source records")

	sourceRows, err := db.queries.ListSources(ctx)
	if err != nil {
		db.log.Error("failed to list sources from db", "error", err)
		return nil, fmt.Errorf("error listing sources: %w", err)
	}

	// Map each sqlc row to the domain model.
	sources := make([]*models.Source, 0, len(sourceRows)) // Initialize with 0 length
	for i := range sourceRows {                           // Iterate safely over slice index
		mappedSource := mapSourceRowToModel(&sourceRows[i])
		if mappedSource != nil { // Avoid appending nil if mapping fails
			sources = append(sources, mappedSource)
		}
	}

	db.log.Debug("source records listed", "count", len(sources))
	return sources, nil
}

// UpdateSource updates an existing source record in the database.
// Note: This updates the entire record based on the provided model.
// The `updated_at` timestamp is automatically set by the query.
func (db *DB) UpdateSource(ctx context.Context, source *models.Source) error {
	db.log.Debug("updating source record", "source_id", source.ID, "name", source.Name)

	// Map domain model to sqlc parameters.
	params := sqlc.UpdateSourceParams{
		Name:              source.Name,
		MetaIsAutoCreated: boolToInt(source.MetaIsAutoCreated),
		MetaTsField:       source.MetaTSField,
		MetaSeverityField: sql.NullString{String: source.MetaSeverityField, Valid: source.MetaSeverityField != ""},
		Host:              source.Connection.Host,
		Username:          source.Connection.Username,
		Password:          source.Connection.Password,
		Database:          source.Connection.Database,
		TableName:         source.Connection.TableName,
		Description:       sql.NullString{String: source.Description, Valid: source.Description != ""},
		TtlDays:           int64(source.TTLDays),
		ID:                int64(source.ID),
	}

	err := db.queries.UpdateSource(ctx, params)
	if err != nil {
		db.log.Error("failed to update source record in db", "error", err, "source_id", source.ID)
		// TODO: Check for specific errors like not found? The sqlc exec doesn't return ErrNoRows usually.
		return fmt.Errorf("error updating source record: %w", err)
	}

	// Fetch updated timestamps? Or assume the caller will re-fetch if needed.
	// For simplicity, we don't update the input model here.

	db.log.Debug("source record updated successfully", "source_id", source.ID)
	return nil
}

// DeleteSource removes a source record from the database by its ID.
func (db *DB) DeleteSource(ctx context.Context, id models.SourceID) error {
	db.log.Debug("deleting source record", "source_id", id)

	err := db.queries.DeleteSource(ctx, int64(id))
	if err != nil {
		db.log.Error("failed to delete source record from db", "error", err, "source_id", id)
		// TODO: Check if error indicates "not found"? sqlc exec doesn't usually.
		return fmt.Errorf("error deleting source record: %w", err)
	}

	db.log.Debug("source record deleted successfully", "source_id", id)
	return nil
}
